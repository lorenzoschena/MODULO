<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Towards customization: accessing MODULO internal modules &mdash; MODULO 2.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Minimum Version of Python and NumPy" href="min_versions.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            MODULO
          </a>
              <div class="version">
                Version 2
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">MODULO: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="what_is_new.html">What is new in this V 2.0?</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="importing_data.html">Importing data</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="black_box.html">Computing decompositions</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">New Tutorial Exercises</a></li>
<li class="toctree-l1"><a class="reference internal" href="min_versions.html">Minimum Version of Python and NumPy</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Towards customization: accessing MODULO internal modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#functions-for-the-pod">Functions for the POD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._k_matrix.CorrelationMatrix"><code class="docutils literal notranslate"><span class="pre">CorrelationMatrix()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._pod_time.Temporal_basis_POD"><code class="docutils literal notranslate"><span class="pre">Temporal_basis_POD()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._pod_space.Spatial_basis_POD"><code class="docutils literal notranslate"><span class="pre">Spatial_basis_POD()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions-for-the-mpod">Functions for the mPOD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._mpod_time.temporal_basis_mPOD"><code class="docutils literal notranslate"><span class="pre">temporal_basis_mPOD()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._mpod_space.spatial_basis_mPOD"><code class="docutils literal notranslate"><span class="pre">spatial_basis_mPOD()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions-for-the-dft">Functions for the DFT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._dft.dft_fit"><code class="docutils literal notranslate"><span class="pre">dft_fit()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions-for-the-dmd-pip">Functions for the DMD (PIP)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._dmd_s.dmd_s"><code class="docutils literal notranslate"><span class="pre">dmd_s()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions-for-the-spod-s">Functions for the SPOD_S</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._spod_s.compute_SPOD_s"><code class="docutils literal notranslate"><span class="pre">compute_SPOD_s()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#functions-for-the-spod-t">Functions for the SPOD_T</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#modulo.core._spod_t.compute_SPOD_t"><code class="docutils literal notranslate"><span class="pre">compute_SPOD_t()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">MODULO</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Towards customization: accessing MODULO internal modules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/single_modules.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="towards-customization-accessing-modulo-internal-modules">
<h1>Towards customization: accessing MODULO internal modules<a class="headerlink" href="#towards-customization-accessing-modulo-internal-modules" title="Permalink to this heading">¶</a></h1>
<p>The methods for each decomposition (POD, DMD, mPOD, etc) are made of different sub-methods.
It is possible to call each of these separately, hence allowing the user to customize the various steps if needed.</p>
<section id="functions-for-the-pod">
<h2>Functions for the POD<a class="headerlink" href="#functions-for-the-pod" title="Permalink to this heading">¶</a></h2>
<p>For example, the method compute_POD_K acts in three steps: 1. compute K, 2. diagonalize it to compute the Psi’s and 3 project to compute the Phi’s.</p>
<p>These are handled by three methods, with use the functions in modulo.core:</p>
<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._k_matrix.CorrelationMatrix">
<span class="sig-prename descclassname"><span class="pre">modulo.core._k_matrix.</span></span><span class="sig-name descname"><span class="pre">CorrelationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_PARTITIONS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MEMORY_SAVING</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float64)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_k_matrix.html#CorrelationMatrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._k_matrix.CorrelationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the temporal correlation matrix, given a data matrix as input. It’s possible to use memory saving
then splitting the computing in different tranches if computationally heavy. If D has been computed using MODULO
then the dimension dim_col and N_PARTITIONS is automatically loaded</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N_T</strong> – int. Number of temporal snapshots</p></li>
<li><p><strong>D</strong> – np.array. Data matrix</p></li>
<li><p><strong>SAVE_K</strong> – bool. If SAVE_K=True, the matrix K is saved on disk. If the MEMORY_SAVING feature is active, this is done by default.</p></li>
<li><p><strong>MEMORY_SAVING</strong> – bool. If MEMORY_SAVING = True, the computation of the correlation matrix is done by steps. It requires the data matrix to be partitioned, following algorithm in MODULO._data_processing.</p></li>
<li><p><strong>FOLDER_OUT</strong> – str. Folder in which the temporal correlation matrix will be stored</p></li>
<li><p><strong>N_PARTITIONS</strong> – int. Number of partitions to be read in computing the correlation matrix. If _data_processing is used to partition the data matrix, this is inherited from the main class</p></li>
<li><p><strong>weights</strong> – weight vector [w_i,….,w_{N_s}] where w_i = area_cell_i/area_grid. Only needed if grid is non-uniform &amp; MEMORY_SAVING== True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>K (: np.array) if the memory saving is not active. None type otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._pod_time.Temporal_basis_POD">
<span class="sig-prename descclassname"><span class="pre">modulo.core._pod_time.</span></span><span class="sig-name descname"><span class="pre">Temporal_basis_POD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_T_POD</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_Modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eig_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'eigh'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_pod_time.html#Temporal_basis_POD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._pod_time.Temporal_basis_POD" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the POD basis. For some theoretical insights, you can find the theoretical background of the proper orthogonal decomposition in a nutshell here: <a class="reference external" href="https://youtu.be/8fhupzhAR_M">https://youtu.be/8fhupzhAR_M</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FOLDER_OUT</strong> – str. Folder in which the results will be saved (if SAVE_T_POD=True)</p></li>
<li><p><strong>K</strong> – np.array. Temporal correlation matrix</p></li>
<li><p><strong>SAVE_T_POD</strong> – bool. A flag deciding whether the results are saved on disk or not. If the MEMORY_SAVING feature is active, it is switched True by default.</p></li>
<li><p><strong>n_Modes</strong> – int. Number of modes that will be computed</p></li>
<li><p><strong>svd_solver</strong> – str. Svd solver to be used throughout the computation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Psi_P: np.array. POD’s Psis</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Sigma_P: np.array. POD’s Sigmas</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._pod_space.Spatial_basis_POD">
<span class="sig-prename descclassname"><span class="pre">modulo.core._pod_space.</span></span><span class="sig-name descname"><span class="pre">Spatial_basis_POD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PSI_P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Sigma_P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MEMORY_SAVING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_PARTITIONS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_SPATIAL_POD</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_pod_space.html#Spatial_basis_POD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._pod_space.Spatial_basis_POD" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computs the POD spatial basis from the temporal basis,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D</strong> – np.array.
matrix on which to project the temporal basis</p></li>
<li><p><strong>PSI_P</strong> – np.array.
POD’s Psis</p></li>
<li><p><strong>Sigma_P</strong> – np.array.
POD’s Sigmas</p></li>
<li><p><strong>MEMORY_SAVING</strong> – bool.
Inherited from main class, if True turns on the MEMORY_SAVING feature, loading the partitions and starting the proper algorithm</p></li>
<li><p><strong>N_T</strong> – int.
Number of temporal snapshots</p></li>
<li><p><strong>FOLDER_OUT</strong> – str.
Folder in which the results are saved if SAVE_SPATIAL_POD = True</p></li>
<li><p><strong>N_PARTITIONS</strong> – int.
Number of partitions to be loaded. If D has been partitioned using MODULO, this parameter is automatically inherited from the main class. To be specified otherwise.</p></li>
<li><p><strong>SAVE_SPATIAL_POD</strong> – bool.
If True, results are saved on disk and released from memory</p></li>
<li><p><strong>rescale</strong> – bool.
If False, the Sigmas are used for the normalization. If True, these are ignored and the normalization is carried out.
For the standard POD, False is the way to go.
However, for other decompositions (eg. the SPOD_s) you must use rescale=True</p></li>
</ul>
</dd>
<dt class="field-even">Return Phi_P<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array.
POD’s Phis</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="functions-for-the-mpod">
<h2>Functions for the mPOD<a class="headerlink" href="#functions-for-the-mpod" title="Permalink to this heading">¶</a></h2>
<blockquote>
<div><p>Similarly, the equivalent version of these functions for the mPOD are:</p>
</div></blockquote>
<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._mpod_time.temporal_basis_mPOD">
<span class="sig-prename descclassname"><span class="pre">modulo.core._mpod_time.</span></span><span class="sig-name descname"><span class="pre">temporal_basis_mPOD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Keep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundaries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MODE</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reduced'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MEMORY_SAVING</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAT</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><span class="pre">int</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_Modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eig_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'svd_sklearn_randomized'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_mpod_time.html#temporal_basis_mPOD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._mpod_time.temporal_basis_mPOD" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the PSIs for the mPOD. In this implementation, a “dft-trick” is proposed, in order to avoid
expansive SVDs. Randomized SVD is used by default for the diagonalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>K</strong> – np.array  Temporal correlation matrix</p></li>
<li><p><strong>dt</strong> – float.
1/fs, the dt between snapshots. Units in seconds.</p></li>
<li><p><strong>Nf</strong> – np.array. Vector collecting the order of the FIR filters used in each scale.</p></li>
<li><p><strong>Ex</strong> – int.
Extension at the boundaries of K to impose the boundary conditions (see boundaries). It must be at least as Nf.</p></li>
<li><p><strong>F_V</strong> – np.array.
Frequency splitting vector, containing the frequencies of each scale (see article). If the time axis is in seconds, these frequencies are in Hz.</p></li>
<li><p><strong>Keep</strong> – np.array.
Vector defining which scale to keep.</p></li>
<li><p><strong>boundaries</strong> – str -&gt; {‘nearest’, ‘reflect’, ‘wrap’ or ‘extrap’}.
In order to avoid ‘edge effects’ if the time correlation matrix is not periodic, several boundary conditions can be used. Options are (from scipy.ndimage.convolve):
‘reflect’ (d c b a | a b c d | d c b a)    The input is extended by reflecting about the edge of the last pixel.
‘nearest’ (a a a a | a b c d | d d d d)    The input is extended by replicating the last pixel.
‘wrap’ (a b c d | a b c d | a b c d)       The input is extended by wrapping around to the opposite edge.</p></li>
<li><p><strong>MODE</strong> – tr -&gt; {‘reduced’, ‘complete’, ‘r’, ‘raw’}
As a final step of this algorithm, the orthogonality is imposed via a QR-factorization. This parameterd define how to perform such factorization, according to numpy.
Options: this is a wrapper to np.linalg.qr(_, mode=MODE). Check numpy’s documentation.
if ‘reduced’ The final basis will not necessarely be full. If ‘complete’ The final basis will always be full</p></li>
<li><p><strong>FOLDER_OUT</strong> – str.
This is the directory where intermediate results will be stored if the memory saving is active.It will be ignored if MEMORY_SAVING=False.</p></li>
<li><p><strong>MEMORY_SAVING</strong> – Bool.
If memory saving is active, the results will be saved locally.  Nevertheless, since Psi_M is usually not expensive, it will be returned.</p></li>
<li><p><strong>SAT</strong> – int.
Maximum number of modes per scale. The user can decide how many modes to compute; otherwise, modulo set the default SAT=100.</p></li>
<li><p><strong>n_Modes</strong> – int.
Total number of modes that will be finally exported</p></li>
<li><p><strong>eig_solver</strong> – str.
This is the eigenvalue solver that will be used. Refer to eigs_swith for the options.</p></li>
</ul>
</dd>
<dt class="field-even">Return PSI_M<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array.
The mPOD PSIs. Yet to be sorted !</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._mpod_space.spatial_basis_mPOD">
<span class="sig-prename descclassname"><span class="pre">modulo.core._mpod_space.</span></span><span class="sig-name descname"><span class="pre">spatial_basis_mPOD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">PSI_M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_PARTITIONS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MEMORY_SAVING</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float64)</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_mpod_space.html#spatial_basis_mPOD"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._mpod_space.spatial_basis_mPOD" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the temporal basis of the mPOD now the spatial ones are computed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D</strong> – Snapshot matrix D: if memory savig is active, this is ignored.</p></li>
<li><p><strong>PSI_M</strong> – np.array.:
The mPOD temporal basis Psi tentatively assembled from all scales</p></li>
<li><p><strong>N_T</strong> – int.
Number of snapshots</p></li>
<li><p><strong>N_PARTITIONS</strong> – int.
Number of partitions in the memory saving</p></li>
<li><p><strong>N_S</strong> – int.
Number of grid points in space</p></li>
<li><p><strong>MEMORY_SAVING</strong> – bool.
Inherited from main class, if True turns on the MEMORY_SAVING feature, loading the partitions and starting the proper algorithm</p></li>
<li><p><strong>FOLDER_OUT</strong> – str.
Folder in which the results are saved if SAVE_SPATIAL_POD = True</p></li>
<li><p><strong>SAVE_SPATIAL_POD</strong> – bool.
If True, results are saved on disk and released from memory</p></li>
<li><p><strong>weights</strong> – np.array
weight vector [w_i,….,w_{N_s}] where w_i = area_cell_i/area_grid. Only needed if grid is non-uniform &amp; MEMORY_SAVING== True</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Phi_M, Psi_M, Sigma_M: np.arrays. The final (sorted) mPOD decomposition</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="functions-for-the-dft">
<h2>Functions for the DFT<a class="headerlink" href="#functions-for-the-dft" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._dft.dft_fit">
<span class="sig-prename descclassname"><span class="pre">modulo.core._dft.</span></span><span class="sig-name descname"><span class="pre">dft_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N_T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_DFT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_dft.html#dft_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._dft.dft_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>This function computes the DFT form the dataset D.
Currently, this does not handle the memory saving feature.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>N_T</strong> – int.
number of snapshots</p></li>
<li><p><strong>F_S</strong> – Sampling frequency (in Hz)</p></li>
<li><p><strong>D</strong> – Snapshot matrix</p></li>
<li><p><strong>FOLDER_OUT</strong> – Folder in which the results are saved if SAVE_SPATIAL_POD = True</p></li>
<li><p><strong>SAVE_DFT</strong> – If True, results are saved on disk and released from memory</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Sorted_Freqs, np.array
Frequency bins, in Hz.</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Phi_F, np.array
(Complex) Spatial structures for each mode</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>SIGMA_F, np.array
(real) amplitude of each modes</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="functions-for-the-dmd-pip">
<h2>Functions for the DMD (PIP)<a class="headerlink" href="#functions-for-the-dmd-pip" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._dmd_s.dmd_s">
<span class="sig-prename descclassname"><span class="pre">modulo.core._dmd_s.</span></span><span class="sig-name descname"><span class="pre">dmd_s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_Modes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_T_DMD</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">svd_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'svd_sklearn_truncated'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_dmd_s.html#dmd_s"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._dmd_s.dmd_s" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the Dynamic Mode Decomposition (DMD) using hte PIP algorithm from Penland.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D_1</strong> – np.array
First portion of the data, i.e. D[:,0:n_t-1]</p></li>
<li><p><strong>D_2</strong> – np.array
Second portion of the data, i.e. D[:,1:n_t]</p></li>
<li><p><strong>Sigma_P</strong> (<em>Phi_P</em><em>, </em><em>Psi_P</em><em>,</em>) – np.arrays
POD decomposition of D1</p></li>
<li><p><strong>F_S</strong> – float
Sampling frequency in Hz</p></li>
<li><p><strong>FOLDER_OUT</strong> – str
Folder in which the results will be saved (if SAVE_T_DMD=True)</p></li>
<li><p><strong>K</strong> – np.array
Temporal correlation matrix</p></li>
<li><p><strong>SAVE_T_POD</strong> – bool
A flag deciding whether the results are saved on disk or not. If the MEMORY_SAVING feature is active, it is switched True by default.</p></li>
<li><p><strong>n_Modes</strong> – int
number of modes that will be computed</p></li>
<li><p><strong>svd_solver</strong> – str,
svd solver to be used</p></li>
</ul>
</dd>
<dt class="field-even">Return1 Phi_D<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array.
DMD’s complex spatial structures</p>
</dd>
<dt class="field-odd">Return2 Lambda_D<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array.
DMD Eigenvalues (of the reduced propagator)</p>
</dd>
<dt class="field-even">Return3 freqs<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array.
Frequencies (in Hz, associated to the DMD modes)</p>
</dd>
<dt class="field-odd">Return4 a0s<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array.
Initial Coefficients of the Modes</p>
</dd>
</dl>
</dd></dl>

<p>For the SPODs, currently these are implemented in a single function.
MODULO acts as a wrapper to these. The memory saving feature on these is not yet implemented.</p>
</section>
<section id="functions-for-the-spod-s">
<h2>Functions for the SPOD_S<a class="headerlink" href="#functions-for-the-spod-s" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._spod_s.compute_SPOD_s">
<span class="sig-prename descclassname"><span class="pre">modulo.core._spod_s.</span></span><span class="sig-name descname"><span class="pre">compute_SPOD_s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_o</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_Modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_SPOD</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MEMORY_SAVING</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_PARTITIONS</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_spod_s.html#compute_SPOD_s"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._spod_s.compute_SPOD_s" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the Spectral POD of your data.
This is the one by Sieber
et al (<a class="reference external" href="https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/spectral-proper-orthogonal-decomposition/DCD8A6EDEFD56F5A9715DBAD38BD461A">https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/spectral-proper-orthogonal-decomposition/DCD8A6EDEFD56F5A9715DBAD38BD461A</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>F_S</strong> – float,
Sampling Frequency [Hz]</p></li>
<li><p><strong>N_o</strong> – float,
Semi-Order of the diagonal filter.
Note that the filter order will be 2 N_o +1 (to make sure it is odd)</p></li>
<li><p><strong>f_c</strong> – float,
cut-off frequency of the diagonal filter</p></li>
<li><p><strong>n_Modes</strong> – float,
number of modes to be computed</p></li>
<li><p><strong>SAVE_SPOD</strong> – bool,
If True, MODULO will save the output in self.FOLDER OUT/MODULO_tmp</p></li>
<li><p><strong>FOLDER_OUT</strong> – string
Define where the out will be stored (ignored if SAVE_POD=False)</p></li>
<li><p><strong>SAVING</strong> (<em>MEMORY</em>) – bool
Define if memory saving is active or not (reduntant; to be improved)
Currently left for compatibility with the rest of MODULO.</p></li>
<li><p><strong>N_PARTITIONS</strong> – int
number of partitions (if memory saving = False, it should be 1).
(reduntant; to be improved)
Currently left for compatibility with the rest of MODULO.</p></li>
</ul>
</dd>
<dt class="field-even">Return Psi_P<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array
SPOD Psis</p>
</dd>
<dt class="field-odd">Return Sigma_P<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array
SPOD Sigmas.</p>
</dd>
<dt class="field-even">Return Phi_P<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array
SPOD Phis</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="functions-for-the-spod-t">
<h2>Functions for the SPOD_T<a class="headerlink" href="#functions-for-the-spod-t" title="Permalink to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="modulo.core._spod_t.compute_SPOD_t">
<span class="sig-prename descclassname"><span class="pre">modulo.core._spod_t.</span></span><span class="sig-name descname"><span class="pre">compute_SPOD_t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">F_S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L_B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">O_B</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">250</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_Modes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SAVE_SPOD</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FOLDER_OUT</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">possible_svds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'svd_sklearn_truncated'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/modulo/core/_spod_t.html#compute_SPOD_t"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#modulo.core._spod_t.compute_SPOD_t" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the Spectral POD of your data.
This is the one by Town
et al (<a class="reference external" href="https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/spectral-proper-orthogonal-decomposition-and-its-relationship-to-dynamic-mode-decomposition-and-resolvent-analysis/EC2A6DF76490A0B9EB208CC2CA037717">https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/spectral-proper-orthogonal-decomposition-and-its-relationship-to-dynamic-mode-decomposition-and-resolvent-analysis/EC2A6DF76490A0B9EB208CC2CA037717</a>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>D</strong> – array.
snapshot matrix to decompose, of size N_S,N_T</p></li>
<li><p><strong>F_S</strong> – float,
Sampling Frequency [Hz]</p></li>
<li><p><strong>L_B</strong> – float,
Lenght of the chunks</p></li>
<li><p><strong>O_B</strong> – float,
Overlapping between blocks in the chunk</p></li>
<li><p><strong>n_Modes</strong> – float,
Number of modes to be computed FOR EACH FREQUENCY</p></li>
<li><p><strong>SAVE_SPOD</strong> – bool,
If True, MODULO will save the output in FOLDER OUT/MODULO_tmp</p></li>
<li><p><strong>possible_svds</strong> – str,
Svd solver to be used throughout the computation</p></li>
</ul>
</dd>
<dt class="field-even">Return Psi_P_hat<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array
Spectra of the SPOD Modes</p>
</dd>
<dt class="field-odd">Return Sigma_P<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array
Amplitudes of the SPOD Modes.</p>
</dd>
<dt class="field-even">Return Phi_P<span class="colon">:</span></dt>
<dd class="field-even"><p>np.array
SPOD Phis</p>
</dd>
<dt class="field-odd">Return freq<span class="colon">:</span></dt>
<dd class="field-odd"><p>float
Frequency bins for the Spectral POD</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="min_versions.html" class="btn btn-neutral float-left" title="Minimum Version of Python and NumPy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, von Karman Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>